\chapter{Giugno}
\label{chap:giugno}

Dopo aver studiato le tecnologie principali legate al progetto, ovvero C\# per la parte backend e Angular per la parte frontend, nel mese di giugno ci siamo cimentati allo sviluppo effettivo del codice.
Diego Bonura ci ha illustrato in più incontri su Microsoft Teams il funzionamento della dashboard e di alcuni widget implementati da lui e dal resto del team. \\ Quando si parla di dashboard si intende 
un'interfaccia grafica concepita per visualizzare dei widget, ovvero delle mini-applicazioni, attraverso i quali visualizzare dati e informazioni.
\\ Abbiamo iniziato quindi a lavorare alla parte frontend sviluppando il primo widget.

\section{Composizione di un widget}
Un widget è una piccola applicazione, semplice e immediata, che mostra all'utente dati e informazioni di solito sotto forma di grafici o tabelle. Nel framework proprietario Loccioni, denominato "Aulos", un widget è composto da diversi file. \\ Prendendo come esempio il Revenue Margin Widget, widget realizzato per visualizzare il margine attuale di ogni commessa aperta legata all'utente, possiamo vedere come ogni widget abbia una classe che estenda la classe padre "Widget" in cui poter inserire diversi parametri di configurazione. In questo caso i parametri che abbiamo deciso di aggiungere ci sono serviti per permettere all'utente di filtrare i dati a seconda del periodo scelto e di associare nuovi ordini al proprio widget insieme a Diego Bonura, Giuseppe Romani e Gabriele Rossetti.
\\

\begin{lstlisting}[caption={File revenue-margin-widget.ts}, style=javaScriptCode]
export class RevenueMarginWidget extends Widget {

    private timeSpanContainerParameter: ContainerParameter;
    private fromDateParameter: DateTimeParameter;
    private toDateParameter: DateTimeParameter;
    private codesParameter: ArrayParameter;

    constructor(injector: Injector, widgetDescriptor: WidgetDescriptor) {
        super(injector, widgetDescriptor);
        this.setSize(700, 140);
    }
    
    ...
    
    }
\end{lstlisting} 
Dove viene gestita invece la logica effettiva del widget, e dove vengono utilizzati i valori dei parametri di configurazione, è all'interno dei file ".component.ts". I components sono la base per costruire un'applicazione in Angular. Ogni component è definito usando un decorator @Component che ha al suo interno un selector, un template e altre proprietà, le quali specificano i metadati richiesti per elaborare il componente. \\
\begin{lstlisting}[caption={Decorator all'interno del file revenue-margin.component.ts}, style=javaScriptCode]
@Component({
    selector: 'app-revenue-margin-widget',
    templateUrl: './revenue-margin.component.html',
    encapsulation: ViewEncapsulation.None,
    changeDetection: ChangeDetectionStrategy.OnPush
})
\end{lstlisting}
L'aspetto grafico del widget viene definito all'interno del template che è un file HTML, in questo caso nel "revenue-margin.component.html". \\
\begin{lstlisting}[caption={File revenue-margin.component.html}, style=javaScriptCode]
<aulos-widget-layout [widget]="widget">
  <aulos-widget-content>
    <div *ngIf="revenuesInfo">
      <kendo-grid [data]="revenuesInfo" [style.height]=widget.heightPx 
            [style.maxHeight]=widget.heightPx style="background-color: white;">
        <kendo-grid-column field="order"></kendo-grid-column>
        <kendo-grid-column field="percentage" format="{0:p0}" 
            [headerStyle]="{'text-align': 'center'}"
          [style]="{'text-align': 'center'}"></kendo-grid-column>
        <kendo-grid-column field="positive" title="trend" 
            [headerStyle]="{'text-align': 'center'}"
          [style]="{'text-align': 'center'}">
          <ng-template kendoGridCellTemplate let-revenuesInfo>
            <i *ngIf="revenuesInfo.positive; else down" class="fa fa-arrow-up" 
                aria-hidden="true" style="color:green"></i>
            <ng-template #down>
              <i class="fa fa-arrow-down" aria-hidden="true" style="color:red"></i>
            </ng-template>
          </ng-template>
        </kendo-grid-column>
      </kendo-grid>
    </div>
  </aulos-widget-content>
</aulos-widget-layout>
\end{lstlisting}
I dati invece vengono presi dal backend tramite un servizio che viene iniettato al component alla sua creazione. Ogni servizio si occupa di fare una chiamata REST e di adattare i dati dal DTO all'interfaccia dati utilizzata dal widget. \\

\begin{lstlisting}[caption={File revenue-margin.service.ts}, style=javaScriptCode]
@Injectable({
  providedIn: 'root'
})
export class RevenueMarginWidgetService {
  private baseUrl: string = environment.apiUrl;
  private widgetsUrl = `${this.baseUrl}/${environment.widgetsUrl}`;

  constructor(
    private http: HttpClient,
    private adapter: RevenuesInfoAdapter
  ) {
  }

  public getRevenueInfo(username: string, codes: string[], from: Date, to: Date): 
        Observable<RevenuesInfo[]> {

    return this.http.post<RevenuesDTO[]>(`${this.widgetsUrl}/revenue`, {
      codes,
      from: from.toJSON(),
      to: to.toJSON()
    }).pipe(
      map((data) => data.map(item => this.adapter.adapt(item))));
  }
}
\end{lstlisting}
Infine ogni widget ha al suo interno un modulo. "In Angular i moduli sono dei container per un blocco coeso di codice dedicato a un dominio dell'applicazione, un flusso di lavoro o un insieme di capacità strettamente collegate. Possono contenere dei components, providers di servizi, e altri file di codice il cui ambito è definito dall'oggetto NgModule che lo contiene. Possono importare funzionalità che sono esportate da altri NgModules, ed esportare funzionalità selezionate per l'utilizzo da parte di altri NgModules" \cite{MODULE}. Nel nostro caso il modulo ha come funzionalità importante quella di registrare all'avvio dell'applicazione il widget utilizzando il WidgetComponentService, definendo alcune informazioni base come l'icona e la descrizione. \\

\begin{lstlisting}[caption={Metodo all'interno del modulo che registra il widget nel sistema}, style=javaScriptCode]
private static registerWidgets(widgetsService: WidgetComponentsService): 
        () => Promise<any> {
    const result = (): Promise<any> => {
      return new Promise((resolve, reject) => {
        const myWidgetDescriptor: WidgetDescriptor = {
          code: 'revenueMarginWidgetCode',
          shortText: 'Revenue Margin',
          longText: 'Descrizione',
          icon: 'fa fa-percent',
          group: 'It Group'
        };
        widgetsService.register(myWidgetDescriptor, RevenueMarginWidget, 
            RevenueMarginComponent);

        resolve();
      });
    };
    return result;
  }
\end{lstlisting}

\section{Widget realizzati nel corso del mese}

Durante il mese di Giugno ci sono stati assegnati i widget da dover implementare nel corso del progetto, metà relativi al reparto IT e l'altra metà al reparto Mobility. I primi sono più focalizzati sul dare informazioni utili ai membri del team Loccioni mentre i secondi sono più legati ai dati relativi ai macchinari venduti ai clienti. I primi a cui abbiamo lavorato sono stati: 
\begin{itemize}
\item 
un widget per visualizzare le novità dei rilasci relativi alle applicazioni legate all'utente
\item 
un widget per vedere il margine attuale delle commesse aperte (il revenue margin widget citato nella sezione precedente)
\item 
un widget che mostra un istogramma con dati generici presi dal database
\item 
un widget per la visualizzazione di andamento e valore di una singola grandezza.
\end{itemize}
Inoltre abbiamo iniziato a lavorare al backend creando controller che ritornassero dati mock da poter utilizzare lato frontend per simularne il comportamento effettivo. 