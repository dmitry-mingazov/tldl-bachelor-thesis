\chapter{User Manual}
\section{Software setup - Frontend}
In order to create a new widget, two classes which extend \textit{BaseWidget} and \textit{BaseWidgetComponent} [\ref{subsec:base}] must be created.\\
The class extending \textit{BaseWidget} must be then decorated with the \textit{WidgetDecorator}, which accepts up to 5 parameters.
\begin{lstlisting}[caption={PieChartWidget example}, style=javaScriptCode]
@WidgetDecorator({
    endpoint: 'tuple',
    type: WidgetTypeEnum.MOBILITY,
    sourceable: true,
    refreshableInfo: {
        refreshable: true,
        defaultRefreshRate: RefreshRateEnum.sec_5
    },
    adapter: PieChartAdapter,
})
export class PieChartWidget extends BaseWidget {

...

}
\end{lstlisting}
This is the structure of the parameters accepted by the decorator [\ref{subsec:widgetDecorator}]:
\begin{lstlisting}[caption={Structure of WidgetOptions}, style=javaScriptCode]
export interface WidgetOptions {
    endpoint: string;
    type: WidgetTypeEnum;
    sourceable?: boolean;
    refreshableInfo?: RefreshableInfo; 
    adapter?: any;
}

export interface RefreshableInfo {
    refreshable: boolean;
    defaultRefreshRate?: RefreshRateEnum;
}
\end{lstlisting}
\begin{itemize}
    \item \textit{endpoint}: indicates which endpoint the widget has to use to take data from.
    \item \textit{type}: indicates the widget type (currently IT/MOBILITY).
    \item \textit{sourceable} (optional): indicates whether or not the widget has a selectable source parameter.
    \item \textit{refreshableInfo} (optional): indicates whether or not the widget has a refresh parameter and can be used to set the default refresh rate.
    \item \textit{adapter} (optional): indicates the adapter class used to transform received data.
\end{itemize}
A class implementing the \textit{Adapter} functional interface can be created.
\begin{lstlisting}[caption={Adapter interface}, style=javaScriptCode]
export interface Adapter {
    adapt(dto: any): any;
}
\end{lstlisting}
The method \textit{getDataCallback} (where the parameter \textit{value} is the data received from the backend) must be implemented inside the class extending \textit{BaseWidgetComponent}. This method will be called each time the widget receives data.\\
\textbf{Note}: \textit{value} will be adapted if an \textit{Adapter} was declared for the \textit{Widget} class.
\begin{lstlisting}[caption={PieChartComponent example}, style=javaScriptCode]
@Component({
    selector: 'app-pie-chart-widget',
    templateUrl: './pie-chart.component.html',
    encapsulation: ViewEncapsulation.None,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class PieChartComponent extends BaseWidgetComponent<PieChartWidget> {

    public data: TupleData[] = [];
  
    ...

    protected getDataCallback(value: any): void {
        this.data = value;
    }
}
\end{lstlisting}

\section{Software setup - Backend}
In order to add a new widget endpoint you need to follow these steps:
\begin{itemize}
    \item Implement the data access layer.
    \item Create a json file in \textit{DiscoveryConfigurations/properties} [\ref{subsec:source}].
    \begin{lstlisting}[caption={{sourcecode}.json example}, style=javaScriptCode]
    {
        "metadata": {
            "meta": {
                "fieldName": "label"
            },
        "properties": {
            "color": [
                {
                    "field": "Passed",
                    "value": "green"
                },
                {
                    "field": "Refused",
                    "value": "red"
                }
            ],
            "field": [
                {
                    "field": "Passed",
                    "value": "ok"
                },
                {
                    "field": "Refused",
                    "value": "ko"
                }
            ]
        }
        },
        "filters": [
            {
                "Code": "time-span",
                "ShortText": "Time span",
                "LongText": "T i m e   s p a n",
                "Type": "number",
                "DefaultValue": "7",
                "Editor": {
                    "Type": "EnumEditor",
                    "Path": "@aulos/parameter-editors",
                    "Options": {
                        "comboValues": [
                            {
                                "label": "1 week",
                                "value": 7
                            },
                            {
                                "label": "2 weeks",
                                "value": 14
                            },
                            {
                                "label": "1 month",
                                "value": 28
                            },
                            {
                                "label": "2 months",
                                "value": 56
                            },
                            {
                                "label": "Forever",
                                "value": 9999
                            }
                        ]
                    }
                }
            }   
        ]
    }
    \end{lstlisting}
    \begin{itemize}
    \item \textit{filters} is an array of AULOS \textit{Parameter}  
    \item \textit{metadata} describes how the data will be altered before being shown.
    
     \textit{properties} contains a set of tuple arrays. Each tuple has a \textit{field}, used to determine the DTO element to be processed, and a \textit{value}, which indicates the value of the property that will be applied.
    \end{itemize}
    \item Create a \textit{DataSource} class which will be used by the controller in order to obtain data from the data access layer [\ref{subsec:creazioneSource}].
    \item Create a class which extends \textit{DiscoveryConfiguration} [\ref{subsec:source}] and call \textit{AddSource} method in the constructor:
        \begin{itemize}
            
            \begin{lstlisting}[caption={TupleDiscoveryConfiguration example}, style=javaScriptCode]
public class TupleDiscoveryConfiguration : DiscoveryConfiguration
    {
        public TupleDiscoveryConfiguration()
        {
            AddSource(new SourceInfo
            {
                TDataSource = typeof(AllRefusedDataSource),
                SourceCode = "allcode",
                LongText = "All refused",
                ShortText = "All refused"
            });

            AddSource(new SourceInfo
            {
                TDataSource = typeof(RefusedTypeDataSource),
                SourceCode = "refusedtype",
                LongText = "Refused type",
                ShortText = "Refused type"
            });
        }
    }                
            \end{lstlisting}
            \item \textit{TDataSource} is the type of the previously created \textit{DataSource}.
            \item \textit{SourceCode} is a unique string equal to the name of the json file previously created.
        \end{itemize}
    \item Create a controller class:
    \begin{itemize}
        \item Define a single POST method taking \textit{GenericRequestDTO} as an argument.
        \item Call \textit{getDataSource<dataSource>}, method of \textit{SourceManagementService}, where \textit{dataSource} is the \textit{DataSource} class previously defined.
        \begin{lstlisting}[caption={HttpPost request in Controller example}, style=javaScriptCode]
        [HttpPost]
        public IActionResult Search([FromBody] GenericRequestDTO request)
        {
            var dataSource = _sourceManagementService.GetDataSource<ITupleDataSource>(request.SourceCode);
            return new ObjectResult(dataSource.GetData(request.Filters));
        }
        \end{lstlisting}
    \end{itemize}
\end{itemize}
